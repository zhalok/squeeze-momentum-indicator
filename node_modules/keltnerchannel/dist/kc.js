'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.kc = kc;

var _ma = require('./ma');

/**
 * Calculates keltner channel
 *
 * @param {Array} data Contains array of objects [{high, low and close}...]
 * @param {Number} period Number of time periods
 * @param {Number} multiplier Width multiplier for the channel
 * @param {Boolean} simple If set SMA is used otherwise EMA
 *
 * @return {Object} keltner channel data - {upper: [], mid: [], lower: []}
 */
function kc(data, period, multiplier) {
    var simple = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    if (!Number.isInteger(period)) {
        throw new Error('Invalid Argument: period should be an Integer');
    }

    if (period <= 0) {
        throw new Error('Invalid Argument: period should be greater than 0');
    }

    if (typeof multiplier !== 'number') {
        throw new Error('Invalid Argument: multiplier should be a Number');
    }

    var tp = [];
    var range = [];

    data.forEach(function (d) {
        if (!d.hasOwnProperty('high') || !d.hasOwnProperty('low') || !d.hasOwnProperty('close')) {
            throw new Error('Invalid Argument: expecting {high, low, close}');
        }

        tp.push((d.high + d.low + d.close) / 3);
        range.push(d.high - d.low);
    });

    var m = simple ? _ma.sma : _ma.ema;

    var mid = m(tp, period);
    var width = m(range, period);
    var upper = [];
    var lower = [];

    for (var i = 0; i < width.length; i++) {
        var w = width[i] * multiplier;
        upper.push(mid[i] + w);
        lower.push(mid[i] - w);
    }

    return {
        upper: upper,
        mid: mid,
        lower: lower
    };
}